package tw.holidaybear.pokedex.data.repository

import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import javax.inject.Inject
import tw.holidaybear.pokedex.data.local.CaptureRecord
import tw.holidaybear.pokedex.data.local.CaptureRecordDao
import tw.holidaybear.pokedex.data.local.Pokemon
import tw.holidaybear.pokedex.data.local.PokemonDao
import tw.holidaybear.pokedex.data.model.CapturedPokemon
import tw.holidaybear.pokedex.data.model.TypeWithCount
import tw.holidaybear.pokedex.data.remote.PokeApiService
import kotlinx.coroutines.flow.Flow
import tw.holidaybear.pokedex.util.PokemonDetailWorker

class PokemonRepository @Inject constructor(
    private val pokeApiService: PokeApiService,
    private val pokemonDao: PokemonDao,
    private val captureRecordDao: CaptureRecordDao,
    private val workManager: WorkManager
) {

    suspend fun fetchAndStorePokemonList() {
        // Check if database already has processed Pokemon
        val processedCount = pokemonDao.getProcessedPokemonCount()
        if (processedCount >= 151) {
            // All Pokemon are processed, skip API fetch
            return
        }

        // Fetch unprocessed Pokemon IDs
        val unprocessedIds = pokemonDao.getUnprocessedPokemonIds()
        if (unprocessedIds.isNotEmpty()) {
            // Enqueue Worker tasks for unprocessed Pokemon
            unprocessedIds.forEach { pokemonId ->
                val workRequest = OneTimeWorkRequestBuilder<PokemonDetailWorker>()
                    .setInputData(workDataOf("POKEMON_ID" to pokemonId))
                    .build()
                workManager.enqueue(workRequest)
            }
            return
        }

        // First launch: fetch from API and store in Room
        val response = pokeApiService.getPokemonList(limit = 151)
        val pokemonList = response.results.map { item ->
            Pokemon(
                id = item.id,
                name = item.name.replaceFirstChar { it.uppercase() },
                imageUrl = "",
                description = null,
                isProcessed = false
            )
        }
        pokemonList.forEach { pokemonDao.insertPokemon(it) }

        // Enqueue WorkManager tasks for processing each Pokemon
        pokemonList.forEach { pokemon ->
            val workRequest = OneTimeWorkRequestBuilder<PokemonDetailWorker>()
                .setInputData(workDataOf("POKEMON_ID" to pokemon.id))
                .build()
            workManager.enqueue(workRequest)
        }
    }

    fun getTypesWithCount(): Flow<List<TypeWithCount>> {
        return pokemonDao.getTypesWithCount()
    }

    fun getPokemonByType(typeId: Int): Flow<List<Pokemon>> {
        return pokemonDao.getPokemonByType(typeId)
    }

    fun getCapturedPokemon(): Flow<List<CapturedPokemon>> {
        return captureRecordDao.getCapturedPokemon()
    }

    suspend fun capturePokemon(pokemonId: Int, categoryType: String) {
        val captureRecord = CaptureRecord(
            captureId = 0, // Auto-generated by Room
            pokemonId = pokemonId,
            captureTimestamp = System.currentTimeMillis(),
            categoryType = categoryType
        )
        captureRecordDao.insertCapture(captureRecord)
    }

    suspend fun releasePokemon(captureId: Long) {
        captureRecordDao.deleteCapture(captureId)
    }
}
