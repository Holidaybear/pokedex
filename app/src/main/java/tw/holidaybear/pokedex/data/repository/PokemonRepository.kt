package tw.holidaybear.pokedex.data.repository

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import tw.holidaybear.pokedex.data.local.CaptureRecord
import tw.holidaybear.pokedex.data.local.CaptureRecordDao
import tw.holidaybear.pokedex.data.local.Pokemon
import tw.holidaybear.pokedex.data.local.PokemonDao
import tw.holidaybear.pokedex.data.local.PokemonType
import tw.holidaybear.pokedex.data.local.Type
import tw.holidaybear.pokedex.data.model.CapturedPokemon
import tw.holidaybear.pokedex.data.model.TypeWithCount
import tw.holidaybear.pokedex.data.remote.PokeApiService
import javax.inject.Inject

class PokemonRepository @Inject constructor(
    private val pokeApiService: PokeApiService,
    private val pokemonDao: PokemonDao,
    private val captureRecordDao: CaptureRecordDao
) {

    suspend fun fetchAndStorePokemonList() {
        val processedCount = pokemonDao.getProcessedPokemonCount()
        if (processedCount < 151) {
            val unprocessedPokemonIds = pokemonDao.getUnprocessedPokemonIds()
            if (unprocessedPokemonIds.isEmpty()) {
                val response = pokeApiService.getPokemonList(151)
                response.results.forEach { item ->
                    pokemonDao.insertPokemon(
                        Pokemon(
                            id = item.id,
                            name = item.name,
                            imageUrl = "",
                            description = null,
                            evolvesFromId = null,
                            isProcessed = false
                        )
                    )
                }
            }

            coroutineScope {
                pokemonDao.getUnprocessedPokemonIds().forEach { pokemonId ->
                    launch {
                        fetchAndProcessSinglePokemon(pokemonId)
                    }
                }
            }
        }
    }

    private suspend fun fetchAndProcessSinglePokemon(pokemonId: Int) {
        try {
            val detailResponse = pokeApiService.getPokemonDetail(pokemonId)
            val imageUrl = detailResponse.sprites.other.officialArtwork.frontDefault

            val speciesResponse = pokeApiService.getPokemonSpecies(pokemonId)
            val description = speciesResponse.flavorTextEntries
                .firstOrNull { it.language.name == "en" }
                ?.flavorText
                ?.replace("", " ") ?: ""

            val evolvesFromId = speciesResponse . evolvesFromSpecies ?. url
            ?.let { url -> url.split("/").lastOrNull { it.isNotBlank() }?.toIntOrNull() }

            detailResponse.types.forEach { pokemonType ->
                val typeName = pokemonType.type.name
                val existingType = pokemonDao.getTypeByName(typeName)
                val typeId = if (existingType != null) {
                    existingType.id
                } else {
                    val newTypeId = typeName.hashCode()
                    pokemonDao.insertType(Type(id = newTypeId, name = typeName))
                    newTypeId
                }
                pokemonDao.insertPokemonType(PokemonType(pokemonId = pokemonId, typeId = typeId))
            }
            pokemonDao.updatePokemonDetails(pokemonId, imageUrl, description, evolvesFromId)
        } catch (e: Exception) {
            // You might want to add more sophisticated error handling here
            e.printStackTrace()
        }
    }

    fun getTypesWithCount(): Flow<List<TypeWithCount>> {
        return pokemonDao.getTypesWithCount()
    }

    fun getPokemonByType(typeId: Int): Flow<List<Pokemon>> {
        return pokemonDao.getPokemonByType(typeId)
    }

    fun getCapturedPokemon(): Flow<List<CapturedPokemon>> {
        return captureRecordDao.getCapturedPokemon()
    }

    suspend fun capturePokemon(pokemonId: Int, categoryType: String) {
        val captureRecord = CaptureRecord(
            captureId = 0, // Auto-generated by Room
            pokemonId = pokemonId,
            captureTimestamp = System.currentTimeMillis(),
            categoryType = categoryType
        )
        captureRecordDao.insertCapture(captureRecord)
    }

    suspend fun releasePokemon(captureId: Long) {
        captureRecordDao.deleteCapture(captureId)
    }

    suspend fun getPokemonDetails(pokemonId: Int): Pokemon? {
        return pokemonDao.getPokemonById(pokemonId)
    }

    fun getTypesForPokemon(pokemonId: Int): Flow<List<Type>> {
        return pokemonDao.getTypesForPokemon(pokemonId)
    }
}
