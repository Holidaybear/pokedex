package tw.holidaybear.pokedex.data.repository

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import tw.holidaybear.pokedex.data.local.CaptureRecord
import tw.holidaybear.pokedex.data.local.CaptureRecordDao
import tw.holidaybear.pokedex.data.local.Pokemon
import tw.holidaybear.pokedex.data.local.PokemonDao
import tw.holidaybear.pokedex.data.local.PokemonType
import tw.holidaybear.pokedex.data.local.Type
import tw.holidaybear.pokedex.data.model.CapturedPokemon
import tw.holidaybear.pokedex.data.model.TypeWithCount
import tw.holidaybear.pokedex.data.remote.PokeApiService
import tw.holidaybear.pokedex.data.model.PokemonAndType
import javax.inject.Inject

class PokemonRepository @Inject constructor(
    private val pokeApiService: PokeApiService,
    private val pokemonDao: PokemonDao,
    private val captureRecordDao: CaptureRecordDao
) {

    fun getProcessedPokemonAndTheirTypes(): Flow<List<PokemonAndType>> {
        return pokemonDao.getProcessedPokemonAndTheirTypes()
    }

    suspend fun fetchAndStorePokemonList(): Result<Unit> {
        return try {
            val processedCount = pokemonDao.getProcessedPokemonCount()
            if (processedCount < 151) {
                val unprocessedPokemonIds = pokemonDao.getUnprocessedPokemonIds()
                if (unprocessedPokemonIds.isEmpty()) {
                    val response = pokeApiService.getPokemonList(151)
                    response.results.forEach { item ->
                        pokemonDao.insertPokemon(
                            Pokemon(
                                id = item.id,
                                name = item.name,
                                imageUrl = "",
                                description = null,
                                evolvesFromId = null,
                                isProcessed = false
                            )
                        )
                    }
                }

                coroutineScope {
                    pokemonDao.getUnprocessedPokemonIds().forEach { pokemonId ->
                        launch {
                            fetchAndProcessSinglePokemon(pokemonId)
                        }
                    }
                }
            }
            Result.success(Unit)
        } catch (e: Exception) {
            e.printStackTrace()
            Result.failure(e)
        }
    }

    private suspend fun fetchAndProcessSinglePokemon(pokemonId: Int) {
        try {
            val detailResponse = pokeApiService.getPokemonDetail(pokemonId)
            val imageUrl = detailResponse.sprites.other.officialArtwork.frontDefault

            detailResponse.types.forEach { pokemonType ->
                val typeName = pokemonType.type.name
                val existingType = pokemonDao.getTypeByName(typeName)
                val typeId = if (existingType != null) {
                    existingType.id
                } else {
                    val newTypeId = typeName.hashCode()
                    pokemonDao.insertType(Type(id = newTypeId, name = typeName))
                    newTypeId
                }
                pokemonDao.insertPokemonType(PokemonType(pokemonId = pokemonId, typeId = typeId))
            }
            pokemonDao.updatePokemonDetails(pokemonId, imageUrl, null, null)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    suspend fun ensureSpeciesInfoIsLoaded(pokemonId: Int): Result<Unit> {
        return try {
            val pokemon = pokemonDao.getPokemonById(pokemonId)
            if (pokemon != null && pokemon.description == null) {
                val speciesResponse = pokeApiService.getPokemonSpecies(pokemonId)
                val description = speciesResponse.flavorTextEntries
                    .firstOrNull { it.language.name == "en" }
                    ?.flavorText
                    ?.replace("", " ") ?: ""

                val evolvesFromId = speciesResponse.evolvesFromSpecies?.url
                    ?.let { url -> url.split("/").lastOrNull { it.isNotBlank() }?.toIntOrNull() }

                pokemonDao.updatePokemonDetails(pokemonId, pokemon.imageUrl, description, evolvesFromId)
            }
            Result.success(Unit)
        } catch (e: Exception) {
            e.printStackTrace()
            Result.failure(e)
        }
    }

    fun getTypesWithCount(): Flow<List<TypeWithCount>> {
        return pokemonDao.getTypesWithCount()
    }

    fun getCapturedPokemon(): Flow<List<CapturedPokemon>> {
        return captureRecordDao.getCapturedPokemon()
    }

    suspend fun capturePokemon(pokemonId: Int, categoryType: String) {
        val captureRecord = CaptureRecord(
            captureId = 0, // Auto-generated by Room
            pokemonId = pokemonId,
            captureTimestamp = System.currentTimeMillis(),
            categoryType = categoryType
        )
        captureRecordDao.insertCapture(captureRecord)
    }

    suspend fun releasePokemon(captureId: Long) {
        captureRecordDao.deleteCapture(captureId)
    }

    suspend fun getPokemonDetails(pokemonId: Int): Pokemon? {
        return pokemonDao.getPokemonById(pokemonId)
    }

    fun getTypesForPokemon(pokemonId: Int): Flow<List<Type>> {
        return pokemonDao.getTypesForPokemon(pokemonId)
    }
}
