package tw.holidaybear.pokedex.data.repository

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import tw.holidaybear.pokedex.data.local.CaptureRecord
import tw.holidaybear.pokedex.data.local.CaptureRecordDao
import tw.holidaybear.pokedex.data.local.Pokemon
import tw.holidaybear.pokedex.data.local.PokemonDao
import tw.holidaybear.pokedex.data.local.PokemonType
import tw.holidaybear.pokedex.data.local.Type
import tw.holidaybear.pokedex.data.model.CapturedPokemon
import tw.holidaybear.pokedex.data.model.TypeWithCount
import tw.holidaybear.pokedex.data.remote.PokeApiService
import tw.holidaybear.pokedex.data.model.PokemonAndType
import javax.inject.Inject

class PokemonRepository @Inject constructor(
    private val pokeApiService: PokeApiService,
    private val pokemonDao: PokemonDao,
    private val captureRecordDao: CaptureRecordDao
) {

    fun getProcessedPokemonAndTheirTypes(): Flow<List<PokemonAndType>> {
        return pokemonDao.getProcessedPokemonAndTheirTypes()
    }

    suspend fun fetchAndStorePokemonList() {
        val processedCount = pokemonDao.getProcessedPokemonCount()
        if (processedCount < 151) {
            val unprocessedPokemonIds = pokemonDao.getUnprocessedPokemonIds()
            if (unprocessedPokemonIds.isEmpty()) {
                val response = pokeApiService.getPokemonList(151)
                response.results.forEach { item ->
                    pokemonDao.insertPokemon(
                        Pokemon(
                            id = item.id,
                            name = item.name,
                            imageUrl = "",
                            description = null,
                            evolvesFromId = null,
                            isProcessed = false
                        )
                    )
                }
            }

            coroutineScope {
                pokemonDao.getUnprocessedPokemonIds().forEach { pokemonId ->
                    launch {
                        fetchAndProcessSinglePokemon(pokemonId)
                    }
                }
            }
        }
    }

    private suspend fun fetchAndProcessSinglePokemon(pokemonId: Int) {
        try {
            val detailResponse = pokeApiService.getPokemonDetail(pokemonId)
            val imageUrl = detailResponse.sprites.other.officialArtwork.frontDefault

            // Step 3: Remove species fetching from initial sync
            // val speciesResponse = pokeApiService.getPokemonSpecies(pokemonId)
            // ... (description and evolvesFromId logic removed)

            detailResponse.types.forEach { pokemonType ->
                val typeName = pokemonType.type.name
                val existingType = pokemonDao.getTypeByName(typeName)
                val typeId = if (existingType != null) {
                    existingType.id
                } else {
                    val newTypeId = typeName.hashCode()
                    pokemonDao.insertType(Type(id = newTypeId, name = typeName))
                    newTypeId
                }
                pokemonDao.insertPokemonType(PokemonType(pokemonId = pokemonId, typeId = typeId))
            }
            // Only update with basic info and mark as processed
            pokemonDao.updatePokemonDetails(pokemonId, imageUrl, null, null)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    suspend fun ensureSpeciesInfoIsLoaded(pokemonId: Int) {
        val pokemon = pokemonDao.getPokemonById(pokemonId)
        // Check if description is null, which implies species info hasn't been fetched
        if (pokemon != null && pokemon.description == null) {
            try {
                val speciesResponse = pokeApiService.getPokemonSpecies(pokemonId)
                val description = speciesResponse.flavorTextEntries
                    .firstOrNull { it.language.name == "en" }
                    ?.flavorText
                    ?.replace("", " ") ?: ""

                val evolvesFromId = speciesResponse.evolvesFromSpecies?.url
                    ?.let { url -> url.split("/").lastOrNull { it.isNotBlank() }?.toIntOrNull() }

                // We already have the image url, so we pass it again
                pokemonDao.updatePokemonDetails(pokemonId, pokemon.imageUrl, description, evolvesFromId)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun getTypesWithCount(): Flow<List<TypeWithCount>> {
        return pokemonDao.getTypesWithCount()
    }

    fun getPokemonByType(typeId: Int): Flow<List<Pokemon>> {
        return pokemonDao.getPokemonByType(typeId)
    }

    fun getCapturedPokemon(): Flow<List<CapturedPokemon>> {
        return captureRecordDao.getCapturedPokemon()
    }

    suspend fun capturePokemon(pokemonId: Int, categoryType: String) {
        val captureRecord = CaptureRecord(
            captureId = 0, // Auto-generated by Room
            pokemonId = pokemonId,
            captureTimestamp = System.currentTimeMillis(),
            categoryType = categoryType
        )
        captureRecordDao.insertCapture(captureRecord)
    }

    suspend fun releasePokemon(captureId: Long) {
        captureRecordDao.deleteCapture(captureId)
    }

    suspend fun getPokemonDetails(pokemonId: Int): Pokemon? {
        return pokemonDao.getPokemonById(pokemonId)
    }

    fun getTypesForPokemon(pokemonId: Int): Flow<List<Type>> {
        return pokemonDao.getTypesForPokemon(pokemonId)
    }
}
