package tw.holidaybear.pokedex.data.repository

import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import javax.inject.Inject
import tw.holidaybear.pokedex.data.local.CaptureRecord
import tw.holidaybear.pokedex.data.local.CaptureRecordDao
import tw.holidaybear.pokedex.data.local.Pokemon
import tw.holidaybear.pokedex.data.local.PokemonDao
import tw.holidaybear.pokedex.data.model.CapturedPokemon
import tw.holidaybear.pokedex.data.model.TypeWithCount
import tw.holidaybear.pokedex.data.remote.PokeApiService
import kotlinx.coroutines.flow.Flow
import tw.holidaybear.pokedex.util.PokemonDetailWorker

class PokemonRepository @Inject constructor(
    private val pokeApiService: PokeApiService,
    private val pokemonDao: PokemonDao,
    private val captureRecordDao: CaptureRecordDao,
    private val workManager: WorkManager
) {

    suspend fun fetchAndStorePokemonList() {
        // Check if database already has processed Pokemon
        val processedCount = pokemonDao.getProcessedPokemonCount()
        if (processedCount < 151) {
            val unprocessedPokemonIds = pokemonDao.getUnprocessedPokemonIds()
            if (unprocessedPokemonIds.isEmpty()) {
                val response = pokeApiService.getPokemonList(151)
                response.results.forEach { item ->
                    pokemonDao.insertPokemon(
                        Pokemon(
                            id = item.id,
                            name = item.name,
                            imageUrl = "",
                            description = null,
                            evolvesFromId = null,
                            isProcessed = false
                        )
                    )
                }
            }
            // Enqueue Worker tasks for unprocessed Pokemon
            pokemonDao.getUnprocessedPokemonIds().forEach { pokemonId ->
                val workRequest = OneTimeWorkRequestBuilder<PokemonDetailWorker>()
                    .setInputData(workDataOf("POKEMON_ID" to pokemonId))
                    .build()
                workManager.enqueue(workRequest)
            }
        }
    }

    fun getTypesWithCount(): Flow<List<TypeWithCount>> {
        return pokemonDao.getTypesWithCount()
    }

    fun getPokemonByType(typeId: Int): Flow<List<Pokemon>> {
        return pokemonDao.getPokemonByType(typeId)
    }

    fun getCapturedPokemon(): Flow<List<CapturedPokemon>> {
        return captureRecordDao.getCapturedPokemon()
    }

    suspend fun capturePokemon(pokemonId: Int, categoryType: String) {
        val captureRecord = CaptureRecord(
            captureId = 0, // Auto-generated by Room
            pokemonId = pokemonId,
            captureTimestamp = System.currentTimeMillis(),
            categoryType = categoryType
        )
        captureRecordDao.insertCapture(captureRecord)
    }

    suspend fun releasePokemon(captureId: Long) {
        captureRecordDao.deleteCapture(captureId)
    }

    suspend fun getPokemonDetails(pokemonId: Int): Pokemon? {
        return pokemonDao.getPokemonById(pokemonId)
    }
}
